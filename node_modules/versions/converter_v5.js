const tinycolor = require("tinycolor2");
const fs = require("fs");
const readline = require("readline");

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

const askQuestion = (query) => {
  return new Promise((resolve) => rl.question(query, resolve));
};

const askForInput = async () => {
  let hex = await askQuestion("Enter a HEX color (e.g. #FABADA): ");
  if (!tinycolor(hex).isValid()) {
    console.log(`The HEX color "${hex}" is not valid. Please try again.`);
    rl.close();
    return;
  }

  let includeConcept;
  do {
    includeConcept = (await askQuestion("Do you want to include a concept/purpose? (yes/no): ")).toLowerCase();
  } while (!["yes", "y", "no", "n"].includes(includeConcept));

  let concept = "color";

  if (includeConcept.startsWith("y")) {
    let conceptName = await askQuestion("Enter the name of the concept (e.g. brand, ui, background): ");
    if (!/^[a-zA-Z0-9.-]+$/.test(conceptName)) {
      console.log("The concept name can only contain letters, numbers, hyphens (-), and dots (.).");
      rl.close();
      return;
    }
    concept = conceptName;
  }

  let includeVariant;
  do {
    includeVariant = (await askQuestion("Do you want to include a variant? (yes/no): ")).toLowerCase();
  } while (!["yes", "y", "no", "n"].includes(includeVariant));

  let variant = null;

  if (includeVariant.startsWith("y")) {
    let variantName = await askQuestion("Enter the variant name (e.g. primary, secondary, tertiary): ");
    if (!/^[a-zA-Z0-9.-]+$/.test(variantName)) {
      console.log("The variant name can only contain letters, numbers, hyphens (-), and dots (.).");
      rl.close();
      return;
    }
    variant = variantName;
  }

  return { hex: hex.trim(), concept, variant };
};

const generateStops = (color) => {
  return {
    lightest: tinycolor(color).lighten(40).toRgbString(),
    lighter: tinycolor(color).lighten(30).toRgbString(),
    light: tinycolor(color).lighten(20).toRgbString(),
    dark: tinycolor(color).darken(20).toRgbString(),
    darker: tinycolor(color).darken(30).toRgbString(),
    darkest: tinycolor(color).darken(40).toRgbString()
  };
};

const main = async () => {
  const input = await askForInput();
  if (!input) return;
  
  const { hex, concept, variant } = input;
  const color = tinycolor(hex);
  const rgb = color.toRgbString();
  const rgba = color.toRgb();
  const hsl = color.toHslString();
  const stops = generateStops(color);

  const stopsRGBA = Object.fromEntries(
    Object.entries(stops).map(([key, val]) => [key, tinycolor(val).toRgbString()])
  );
  const stopsHSL = Object.fromEntries(
    Object.entries(stops).map(([key, val]) => [key, tinycolor(val).toHslString()])
  );

  // Ask user which formats to generate for 'format' files
  const generateRGBFormat = (await askQuestion("Do you want to export formats in RGB? (yes/no): ")).toLowerCase().startsWith("y");
  const generateRGBAFormat = (await askQuestion("Do you want to export formats in RGBA? (yes/no): ")).toLowerCase().startsWith("y");
  const generateHSLFormat = (await askQuestion("Do you want to export formats in HSL? (yes/no): ")).toLowerCase().startsWith("y");

  // Ask user which formats to generate for 'token' files
  const generateRGBToken = (await askQuestion("Do you want to export tokens in RGB? (yes/no): ")).toLowerCase().startsWith("y");
  const generateRGBAToken = (await askQuestion("Do you want to export tokens in RGBA? (yes/no): ")).toLowerCase().startsWith("y");
  const generateHSLSpecialToken = (await askQuestion("Do you want to export tokens in HSL? (yes/no): ")).toLowerCase().startsWith("y");

  // Format files generation based on user input
  if (generateRGBFormat) {
    const colorDataRGB = { HEX: hex, RGB: rgb, stops };
    fs.writeFileSync("formats_rgb.json", JSON.stringify(colorDataRGB, null, 2));
    console.log("Color data saved as formats_rgb.json");
  }

  if (generateRGBAFormat) {
    const colorDataRGBA = { HEX: hex, RGBA: `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`, stops: stopsRGBA };
    fs.writeFileSync("formats_rgba.json", JSON.stringify(colorDataRGBA, null, 2));
    console.log("Color data saved as formats_rgba.json");
  }

  if (generateHSLFormat) {
    const colorDataHSL = { HEX: hex, HSL: hsl, stops: stopsHSL };
    fs.writeFileSync("formats_hsl.json", JSON.stringify(colorDataHSL, null, 2));
    console.log("Color data saved as formats_hsl.json");
  }

  // Tokens Data generation based on user input
  const tokensData = { color: {} };
  
  if (variant) {
    tokensData.color[concept] = { [variant]: { value: hex, type: "color" } };
  } else {
    tokensData.color[concept] = { value: hex, type: "color" };
  }

  // Add shades to tokens (for all formats)
  ["lightest", "lighter", "light", "dark", "darker", "darkest"].forEach((shade) => {
    if (variant) {
      tokensData.color[concept][variant][shade] = { value: tinycolor(stops[shade]).toHexString(), type: "color" };
    } else {
      tokensData.color[concept][shade] = { value: tinycolor(stops[shade]).toHexString(), type: "color" };
    }
  });

  // General tokens file
  fs.writeFileSync("tokens.json", JSON.stringify(tokensData, null, 2));
  console.log("Tokens Studio data saved as tokens.json");

  // RGB tokens generation
  if (generateRGBToken) {
    const tokensRGBData = { color: {} };
    if (variant) {
      tokensRGBData.color[concept] = { [variant]: { value: rgb, type: "color" } };
    } else {
      tokensRGBData.color[concept] = { value: rgb, type: "color" };
    }

    ["lightest", "lighter", "light", "dark", "darker", "darkest"].forEach((shade) => {
      if (variant) {
        tokensRGBData.color[concept][variant][shade] = { value: tinycolor(stops[shade]).toRgbString(), type: "color" };
      } else {
        tokensRGBData.color[concept][shade] = { value: tinycolor(stops[shade]).toRgbString(), type: "color" };
      }
    });
    fs.writeFileSync("tokens_rgb.json", JSON.stringify(tokensRGBData, null, 2));
    console.log("Tokens RGB data saved as tokens_rgb.json");
  }

  // RGBA tokens generation
  if (generateRGBAToken) {
    const tokensRGBAData = { color: {} };
    if (variant) {
      tokensRGBAData.color[concept] = { [variant]: { value: `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`, type: "color" } };
    } else {
      tokensRGBAData.color[concept] = { value: `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`, type: "color" };
    }

    ["lightest", "lighter", "light", "dark", "darker", "darkest"].forEach((shade) => {
      if (variant) {
        tokensRGBAData.color[concept][variant][shade] = { value: tinycolor(stops[shade]).toRgbString(), type: "color" };
      } else {
        tokensRGBAData.color[concept][shade] = { value: tinycolor(stops[shade]).toRgbString(), type: "color" };
      }
    });
    fs.writeFileSync("tokens_rgba.json", JSON.stringify(tokensRGBAData, null, 2));
    console.log("Tokens RGBA data saved as tokens_rgba.json");
  }

  // HSL tokens generation
  if (generateHSLSpecialToken) {
    const tokensHSLData = { color: {} };
    if (variant) {
      tokensHSLData.color[concept] = { [variant]: { value: hsl, type: "color" } };
    } else {
      tokensHSLData.color[concept] = { value: hsl, type: "color" };
    }

    ["lightest", "lighter", "light", "dark", "darker", "darkest"].forEach((shade) => {
      if (variant) {
        tokensHSLData.color[concept][variant][shade] = { value: tinycolor(stops[shade]).toHslString(), type: "color" };
      } else {
        tokensHSLData.color[concept][shade] = { value: tinycolor(stops[shade]).toHslString(), type: "color" };
      }
    });
    fs.writeFileSync("tokens_hsl.json", JSON.stringify(tokensHSLData, null, 2));
    console.log("Tokens HSL data saved as tokens_hsl.json");
  }

  rl.close();
};

main();
