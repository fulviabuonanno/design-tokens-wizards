const tinycolor = require("tinycolor2");
const fs = require("fs");
const readline = require("readline");

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

// Función para pedir el color HEX, concepto y nombre de variante
const askForInput = () => {
  return new Promise((resolve) => {
    rl.question("Enter a HEX color (e.g. #FABADA): ", (hex) => {
      // Validar que el color HEX sea correcto
      if (!tinycolor(hex).isValid()) {
        console.log(`The HEX color "${hex}" is not valid. Please try again.`);
        rl.close();
        return;
      }

      // Preguntar si deseas incluir un concepto/purpose
      rl.question("Do you want to include a concept/purpose (e.g. brand, ui, background)? (yes/no): ", (includeConcept) => {
        let concept = null;

        if (includeConcept.toLowerCase() === "yes") {
          rl.question("Enter the name of the concept (e.g. brand, ui, background): ", (conceptName) => {
            // Validación para concepto: solo letras, números, guiones y puntos
            const isValidConcept = /^[a-zA-Z0-9.-]+$/.test(conceptName);
            if (!isValidConcept) {
              console.log("The concept can only contain letters, numbers, hyphens (-), and dots (.).");
              rl.close();
              return;
            }

            concept = conceptName;  // Guardar el nombre del concepto

            // Preguntar si deseas nombrar una variante
            rl.question("Do you want to name a variant for this color (e.g. primary, secondary, tertiary)? (yes/no): ", (hasVariant) => {
              let variant = null;

              if (hasVariant.toLowerCase() === "yes") {
                rl.question("Enter the variant name (e.g. primary, secondary, tertiary): ", (variantName) => {
                  // Validar el nombre de la variante
                  const isValidVariant = /^[a-zA-Z0-9.-]+$/.test(variantName);
                  if (!isValidVariant) {
                    console.log("The variant name can only contain letters, numbers, hyphens (-), and dots (.).");
                    rl.close();
                    return;
                  }

                  variant = variantName;  // Guardar el nombre de la variante
                  resolve({ hex: hex.trim(), concept, variant });
                });
              } else {
                resolve({ hex: hex.trim(), concept, variant });
              }
            });
          });
        } else {
          resolve({ hex: hex.trim(), concept: null, variant: null });
        }
      });
    });
  });
};

// Función para generar los "stops"
const generateStops = (color) => {
  return {
    lightest: color.lighten(40).toHexString(),
    lighter: color.lighten(30).toHexString(),
    light: color.lighten(20).toHexString(),
    dark: color.darken(20).toHexString(),
    darker: color.darken(30).toHexString(),
    darkest: color.darken(40).toHexString()
  };
};

// Función principal
const main = async () => {
  const { hex, concept, variant } = await askForInput();  // Pedir el color HEX, concepto y nombre
  const color = tinycolor(hex);

  // Convertir a RGB
  const rgb = color.toRgbString();

  // Generar los stops (diferentes tonos del color)
  const stops = generateStops(color);

  // Crear el objeto de datos para output_color
  const colorData = {
    HEX: hex,
    RGB: rgb,
    stops: stops
  };

  // Guardar el archivo output_color.json
  const outputColorFilename = "formats.json";
  fs.writeFileSync(outputColorFilename, JSON.stringify(colorData, null, 2));
  console.log(`Color data saved as ${outputColorFilename}`);

  // Crear el objeto de datos para tokens.json (Tokens Studio format)
  const tokensData = {
    color: {}
  };

  // Si se incluye concepto, añadir el color bajo el concepto
  if (concept) {
    tokensData.color[concept] = {};

    // Si hay variante, añadir el color bajo la variante
    if (variant) {
      tokensData.color[concept][variant] = {
        value: hex,
        type: "color"
      };
    } else {
      // Si no hay variante, añadir solo el color bajo el concepto
      tokensData.color[concept] = {
        value: hex,
        type: "color"
      };
    }

    // Los stops estarán bajo el concepto (si existe) o directamente en el objeto color
    tokensData.color[concept].lightest = {
      value: stops.lightest,
      type: "color"
    };
    tokensData.color[concept].lighter = {
      value: stops.lighter,
      type: "color"
    };
    tokensData.color[concept].light = {
      value: stops.light,
      type: "color"
    };
    tokensData.color[concept].dark = {
      value: stops.dark,
      type: "color"
    };
    tokensData.color[concept].darker = {
      value: stops.darker,
      type: "color"
    };
    tokensData.color[concept].darkest = {
      value: stops.darkest,
      type: "color"
    };
  } else {
    // Si no hay concepto, incluir solo el color directamente bajo "color"
    tokensData.color.value = {
      value: hex,
      type: "color"
    };

    // Incluir stops sin concepto
    tokensData.color.lightest = {
      value: stops.lightest,
      type: "color"
    };
    tokensData.color.lighter = {
      value: stops.lighter,
      type: "color"
    };
    tokensData.color.light = {
      value: stops.light,
      type: "color"
    };
    tokensData.color.dark = {
      value: stops.dark,
      type: "color"
    };
    tokensData.color.darker = {
      value: stops.darker,
      type: "color"
    };
    tokensData.color.darkest = {
      value: stops.darkest,
      type: "color"
    };
  }

  // Guardar el archivo tokens.json
  const tokensFilename = "tokens.json";
  fs.writeFileSync(tokensFilename, JSON.stringify(tokensData, null, 2));
  console.log(`Tokens Studio data saved as ${tokensFilename}`);

  rl.close();
};

main();
