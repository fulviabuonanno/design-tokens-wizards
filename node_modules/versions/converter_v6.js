const tinycolor = require("tinycolor2");
const fs = require("fs");
const readline = require("readline");

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

const askQuestion = (query) => {
  return new Promise((resolve) => rl.question(query, resolve));
};

const askForInput = async () => {
  let hex = await askQuestion("Enter a HEX color (e.g. #FABADA): ");
  if (!tinycolor(hex).isValid()) {
    console.log(`The HEX color "${hex}" is not valid. Please try again.`);
    rl.close();
    return;
  }

  console.log("\nNow, let's give a name to this color");

  let includeConcept;
  do {
    includeConcept = (await askQuestion("Do you want to include a concept/purpose? (yes/no): ")).toLowerCase();
  } while (!["yes", "y", "no", "n"].includes(includeConcept));

  let concept = "color";

  if (includeConcept.startsWith("y")) {
    let conceptName = await askQuestion("Enter the name of the concept (e.g. brand, ui, background): ");
    if (!/^[a-zA-Z0-9.-]+$/.test(conceptName)) {
      console.log("The concept name can only contain letters, numbers, hyphens (-), and dots (.).");
      rl.close();
      return;
    }
    concept = conceptName;
  }

  let includeVariant;
  do {
    includeVariant = (await askQuestion("Do you want to include a variant? (yes/no): ")).toLowerCase();
  } while (!["yes", "y", "no", "n"].includes(includeVariant));

  let variant = null;

  if (includeVariant.startsWith("y")) {
    let variantName = await askQuestion("Enter the variant name (e.g. primary, secondary, tertiary): ");
    if (!/^[a-zA-Z0-9.-]+$/.test(variantName)) {
      console.log("The variant name can only contain letters, numbers, hyphens (-), and dots (.).");
      rl.close();
      return;
    }
    variant = variantName;
  }

  return { hex: hex.trim(), concept, variant };
};

const generateStops = (color) => {
  return {
    lightest: { value: tinycolor(color).lighten(40).toRgbString() },
    lighter: tinycolor(color).lighten(30).toRgbString(),
    light: tinycolor(color).lighten(20).toRgbString(),
    dark: tinycolor(color).darken(20).toRgbString(),
    darker: tinycolor(color).darken(30).toRgbString(),
    darkest: tinycolor(color).darken(40).toRgbString()
  };
};

const main = async () => {
  const input = await askForInput();
  if (!input) return;

  const { hex, concept, variant } = input;
  const color = tinycolor(hex);
  const rgb = color.toRgbString();
  const rgba = color.toRgb();
  const hsl = color.toHslString();
  const stops = generateStops(color);

  const stopsRGBA = Object.fromEntries(
    Object.entries(stops).map(([key, val]) => [key, tinycolor(val).toRgbString()])
  );
  const stopsHSL = Object.fromEntries(
    Object.entries(stops).map(([key, val]) => [key, tinycolor(val).toHslString()])
  );

  // Ask user which formats to generate for both formats and tokens
  console.log("\nNow, please select in which formats would you like to have your colors (HEX would be always the default)");

  let exportFormatAndToken = async (format) => {
    const answer = (await askQuestion(`Do you want to export in ${format}? (yes/no): `)).toLowerCase();
    return answer.startsWith("y");
  };

  const generateRGB = await exportFormatAndToken("RGB");
  const generateRGBA = await exportFormatAndToken("RGBA");
  const generateHSL = await exportFormatAndToken("HSL");

  // Format files generation based on user input
  fs.mkdirSync("formats", { recursive: true });
  if (generateRGB) {
    const colorDataRGB = { HEX: hex, RGB: rgb, stops };
    fs.writeFileSync("formats/formats_rgb.json", JSON.stringify({ RGB: rgb, stops: { ...stops, lightest: stops.lightest.value } }, null, 2));
    console.log("Color data saved as formats/formats_rgb.json");
  }

  if (generateRGBA) {
    const colorDataRGBA = { HEX: hex, RGBA: `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`, stops: stopsRGBA };
    fs.writeFileSync("formats/formats_rgba.json", JSON.stringify({ RGBA: `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`, stops: { ...stopsRGBA, lightest: stopsRGBA.lightest.value } }, null, 2));
    console.log("Color data saved as formats/formats_rgba.json");
  }

  if (generateHSL) {
    const colorDataHSL = { HEX: hex, HSL: hsl, stops: stopsHSL };
    fs.writeFileSync("formats/formats_hsl.json", JSON.stringify({ HSL: hsl, stops: { ...stopsHSL, lightest: stopsHSL.lightest.value } }, null, 2));
    console.log("Color data saved as formats/formats_hsl.json");
  }

  // Tokens Data generation based on user input
  const tokensData = { color: {} };
  
  if (variant) {
    tokensData.color[concept] = { [variant]: { value: hex, type: "color" } };
  } else {
    tokensData.color[concept] = { value: hex, type: "color" };
  }

  // Add shades to tokens (for all formats)
  tokensData.color[concept].lightest = { value: tinycolor(stops.lightest.value).toHexString(), type: "color" };
  ["lighter", "light", "dark", "darker", "darkest"].forEach((shade) => {
    if (variant) {
      tokensData.color[concept][variant][shade] = { value: tinycolor(stops[shade]).toHexString(), type: "color" };
    } else {
      tokensData.color[concept][shade] = { value: tinycolor(stops[shade]).toHexString(), type: "color" };
    }
  });

  fs.mkdirSync("tokens", { recursive: true });
  fs.writeFileSync("tokens/tokens.json", JSON.stringify(tokensData, null, 2));
  console.log("Tokens Studio data saved as tokens/tokens.json");

  // RGB tokens generation
  if (generateRGB) {
    const tokensRGBData = { color: {} };
    if (variant) {
      tokensRGBData.color[concept] = { [variant]: { value: rgb, type: "color" } };
    } else {
      tokensRGBData.color[concept] = { value: rgb, type: "color" };
    }

    tokensRGBData.color[concept].lightest = { value: tinycolor(stops.lightest.value).toRgbString(), type: "color" };
    ["lighter", "light", "dark", "darker", "darkest"].forEach((shade) => {
      if (variant) {
        tokensRGBData.color[concept][variant][shade] = { value: tinycolor(stops[shade]).toRgbString(), type: "color" };
      } else {
        tokensRGBData.color[concept][shade] = { value: tinycolor(stops[shade]).toRgbString(), type: "color" };
      }
    });
    fs.writeFileSync("tokens/tokens_rgb.json", JSON.stringify(tokensRGBData, null, 2));
    console.log("Tokens RGB data saved as tokens/tokens_rgb.json");
  }

  // RGBA tokens generation
  if (generateRGBA) {
    const tokensRGBAData = { color: {} };
    if (variant) {
      tokensRGBAData.color[concept] = { [variant]: { value: `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`, type: "color" } };
    } else {
      tokensRGBAData.color[concept] = { value: `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`, type: "color" };
    }

    tokensRGBAData.color[concept].lightest = { value: tinycolor(stops.lightest.value).toRgbString(), type: "color" };
    ["lighter", "light", "dark", "darker", "darkest"].forEach((shade) => {
      if (variant) {
        tokensRGBAData.color[concept][variant][shade] = { value: tinycolor(stops[shade]).toRgbString(), type: "color" };
      } else {
        tokensRGBAData.color[concept][shade] = { value: tinycolor(stops[shade]).toRgbString(), type: "color" };
      }
    });
    fs.writeFileSync("tokens/tokens_rgba.json", JSON.stringify(tokensRGBAData, null, 2));
    console.log("Tokens RGBA data saved as tokens/tokens_rgba.json");
  }

  // HSL tokens generation
  if (generateHSL) {
    const tokensHSLData = { color: {} };
    if (variant) {
      tokensHSLData.color[concept] = { [variant]: { value: hsl, type: "color" } };
    } else {
      tokensHSLData.color[concept] = { value: hsl, type: "color" };
    }

    tokensHSLData.color[concept].lightest = { value: tinycolor(stops.lightest.value).toHslString(), type: "color" };
    ["lighter", "light", "dark", "darker", "darkest"].forEach((shade) => {
      if (variant) {
        tokensHSLData.color[concept][variant][shade] = { value: tinycolor(stops[shade]).toHslString(), type: "color" };
      } else {
        tokensHSLData.color[concept][shade] = { value: tinycolor(stops[shade]).toHslString(), type: "color" };
      }
    });
    fs.writeFileSync("tokens/tokens_hsl.json", JSON.stringify(tokensHSLData, null, 2));
    console.log("Tokens HSL data saved as tokens/tokens_hsl.json");
  }

  rl.close();
};

main();
