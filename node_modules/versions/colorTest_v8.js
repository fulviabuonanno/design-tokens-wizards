const fs = require("fs");
const tinycolor = require("tinycolor2");
const readline = require("readline");

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

// Pedir el color HEX obligatorio
const askForHex = () => {
  return new Promise((resolve) => {
    rl.question("Enter a HEX color (required): ", (input) => {
      const hex = input.trim();
      resolve(hex);
    });
  });
};

// Pedir el nombre para el color
const askForColorName = () => {
  return new Promise((resolve) => {
    rl.question("Enter a name for the color: ", (name) => {
      resolve(name.trim());
    });
  });
};

// Función principal
const main = async () => {
  const hex = await askForHex(); // Pedir el color HEX
  const colorName = await askForColorName(); // Pedir el nombre del color

  const color = tinycolor(hex); // Crear el color con tinycolor2

  if (!color.isValid()) {
    console.log(`The color "${hex}" is not valid. Exiting.`);
    rl.close();
    return;
  }

  console.log(`Valid color detected: ${colorName} (${hex})`);

  // Crear los objetos para formatos
  const colorTokens = {
    formats: {
      HEX: color.toHexString(),
      RGB: color.toRgbString(),
      HSL: color.toHslString(),
    },
    stops: {},
  };

  // Crear los stops (colores de luz y oscuridad)
  const stopNames = ['Lightest', 'Lighter', 'Light', 'Dark', 'Darker', 'Darkest'];
  stopNames.forEach(stopName => {
    let stopColor;

    // Asegurar que la librería funcione para cada stop (ajustando la luz o oscuridad)
    switch (stopName) {
      case 'Lightest':
        stopColor = color.lighten(40);
        break;
      case 'Lighter':
        stopColor = color.lighten(30);
        break;
      case 'Light':
        stopColor = color.lighten(20);
        break;
      case 'Dark':
        stopColor = color.darken(20);
        break;
      case 'Darker':
        stopColor = color.darken(30);
        break;
      case 'Darkest':
        stopColor = color.darken(40);
        break;
      default:
        stopColor = color;
    }

    colorTokens.stops[stopName] = {
      HEX: stopColor.toHexString(),
      RGB: stopColor.toRgbString(),
      HSL: stopColor.toHslString(),
    };
  });

  // Verificar si los datos son correctos
  console.log("Generated color tokens:", colorTokens);

  // Escribir en archivos JSON
  fs.writeFileSync("color_formats.json", JSON.stringify(colorTokens.formats, null, 2));
  fs.writeFileSync("color_stops.json", JSON.stringify(colorTokens.stops, null, 2));

  console.log("Color data has been saved to color_formats.json and color_stops.json");

  rl.close();
};

main();
