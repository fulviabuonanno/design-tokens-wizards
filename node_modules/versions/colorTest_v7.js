const fs = require("fs");
const tinycolor = require("tinycolor2");
const readline = require("readline");

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

// Función para preguntar si incluir cada formato
const askForFormat = (format) => {
  return new Promise((resolve) => {
    rl.question(`Do you want to include ${format.toUpperCase()} format? (yes/no): `, (input) => {
      resolve(input.toLowerCase() === 'yes');
    });
  });
};

// Función para pedir el color HEX obligatorio
const askForHex = () => {
  return new Promise((resolve) => {
    rl.question("Enter a HEX color (required): ", (input) => {
      const hex = input.trim();
      resolve(hex);
    });
  });
};

// Función para preguntar el nombre del color
const askForColorName = () => {
  return new Promise((resolve) => {
    rl.question("Enter a name for the color: ", (name) => {
      resolve(name.trim());
    });
  });
};

const main = async () => {
  const hex = await askForHex(); // Pedir el color HEX obligatorio
  const colorName = await askForColorName(); // Pedir el nombre del color
  const includeRGB = await askForFormat("rgb");
  const includeRGBA = await askForFormat("rgba");
  const includeHSL = await askForFormat("hsl");

  const colorTokens = {};

  // Verificar si el color es válido
  const color = tinycolor(hex);

  if (!color.isValid()) {
    console.log(`The color "${hex}" is not valid. Exiting.`);
    rl.close();
    return; // Salir si el color no es válido
  }

  // Crear el objeto para el color
  colorTokens[colorName] = {
    formats: {},
    stops: {}
  };

  console.log(`Valid color detected: ${hex} as ${colorName}`);

  // Siempre incluir HEX en los resultados
  colorTokens[colorName].formats.HEX = color.toHexString();

  // Generación de formatos según las respuestas del usuario
  if (includeRGB) {
    colorTokens[colorName].formats.RGB = color.toRgbString();
  }
  if (includeRGBA) {
    colorTokens[colorName].formats.RGBA = color.setAlpha(0.5).toRgbString();
  }
  if (includeHSL) {
    colorTokens[colorName].formats.HSL = color.toHslString();
  }

  // Crear los stops en todos los formatos según los colores generados
  const stopNames = ['Lightest', 'Lighter', 'Light', 'Dark', 'Darker', 'Darkest'];
  stopNames.forEach(stopName => {
    let stopColor;

    // Asegúrate de que se apliquen correctamente los métodos de iluminación y oscurecimiento
    switch (stopName) {
      case 'Lightest':
        stopColor = color.lighten(40);
        break;
      case 'Lighter':
        stopColor = color.lighten(30);
        break;
      case 'Light':
        stopColor = color.lighten(20);
        break;
      case 'Dark':
        stopColor = color.darken(20);
        break;
      case 'Darker':
        stopColor = color.darken(30);
        break;
      case 'Darkest':
        stopColor = color.darken(40);
        break;
      default:
        stopColor = color;
    }

    // Mostrar el color de cada stop
    console.log(`Stop ${stopName}:`, stopColor.toString());

    // Aquí validamos que los valores de stopColor sean correctos
    if (stopColor) {
      colorTokens[colorName].stops[stopName] = {};

      // Agregar los formatos según las respuestas del usuario
      if (includeRGB) {
        colorTokens[colorName].stops[stopName].RGB = stopColor.toRgbString();
      }
      if (includeRGBA) {
        colorTokens[colorName].stops[stopName].RGBA = stopColor.setAlpha(0.5).toRgbString();
      }
      if (includeHSL) {
        colorTokens[colorName].stops[stopName].HSL = stopColor.toHslString();
      }
      colorTokens[colorName].stops[stopName].HEX = stopColor.toHexString();  // Siempre incluir HEX
    } else {
      console.log(`Error with stop color for ${stopName}.`);
    }
  });

  // Verificar si hay datos antes de escribir el archivo
  console.log("Final color tokens data:", colorTokens);

  // Asegurémonos de que tenemos datos antes de escribir el archivo
  if (Object.keys(colorTokens).length > 0) {
    try {
      // Escribir en un archivo JSON
      const jsonString = JSON.stringify(colorTokens, null, 2); // JSON.stringify con indentación
      fs.writeFileSync("tokens.json", jsonString);  // Guardar en formato JSON
      console.log("Color data has been saved to tokens.json");
    } catch (error) {
      console.log("Error writing file:", error);
    }
  } else {
    console.log("No valid color data to save.");
  }
  rl.close();
};

main();
