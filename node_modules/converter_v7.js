const tinycolor = require("tinycolor2");
const fs = require("fs");
const readline = require("readline");

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

const askQuestion = (query) => {
  return new Promise((resolve) => rl.question(query, resolve));
};

const askForInput = async () => {
  console.log("\n=======================================");
  console.log(" üîµ NAMING YOUR COLOR");
  console.log("=======================================\n");

  let hex = await askQuestion("üé® Enter a HEX color (e.g. #FABADA): ");
  if (!tinycolor(hex).isValid()) {
    console.log(`‚ùå The HEX color "${hex}" is not valid. Please try again.`);
    rl.close();
    return;
  }

  console.log("\nNow, let's give a name to this color.");
  let concept = await askQuestion("üìù Enter the name of the concept (e.g. brand, ui, background) or press Enter to skip: ");
  concept = concept.trim() || "color"; // Default to "color" if skipped

  if (concept && !/^[a-zA-Z0-9.-]+$/.test(concept)) {
    console.log("‚ùå The concept name can only contain letters, numbers, hyphens (-), and dots (.).");
    rl.close();
    return;
  }

  let variant = await askQuestion("üé® Enter a variant name (e.g. primary, secondary) or press Enter to skip: ");
  variant = variant.trim() || null; // Null if skipped

  if (variant && !/^[a-zA-Z0-9.-]+$/.test(variant)) {
    console.log("‚ùå The variant name can only contain letters, numbers, hyphens (-), and dots (.).");
    rl.close();
    return;
  }

  console.log("\n=======================================");
  console.log(" üîÑ CONVERTING TO FORMATS");
  console.log("=======================================\n");

  console.log("Now, please select in which formats you would like to have your colors.");
  console.log("(HEX will always be included by default.)\n");

  let generateRGB = (await askQuestion("üìå Include RGB format? (yes/no): ")).toLowerCase().startsWith("y");
  let generateRGBA = (await askQuestion("üìå Include RGBA format? (yes/no): ")).toLowerCase().startsWith("y");
  let generateHSL = (await askQuestion("üìå Include HSL format? (yes/no): ")).toLowerCase().startsWith("y");

  return { hex: hex.trim(), concept, variant, generateRGB, generateRGBA, generateHSL };
};

const generateStops = (color) => {
  return {
    lightest: tinycolor(color).lighten(40).toHexString(),
    lighter: tinycolor(color).lighten(30).toHexString(),
    light: tinycolor(color).lighten(20).toHexString(),
    dark: tinycolor(color).darken(20).toHexString(),
    darker: tinycolor(color).darken(30).toHexString(),
    darkest: tinycolor(color).darken(40).toHexString()
  };
};

const main = async () => {
  const input = await askForInput();
  if (!input) return;

  const { hex, concept, variant, generateRGB, generateRGBA, generateHSL } = input;
  const color = tinycolor(hex);
  const rgb = color.toRgbString();
  const rgba = color.toRgb();
  const hsl = color.toHslString();
  const stops = generateStops(color);

  console.log("\n=======================================");
  console.log(" üìÇ GENERATING OUTPUT FILES");
  console.log("=======================================\n");

  if (!fs.existsSync("formats")) fs.mkdirSync("formats");
  if (!fs.existsSync("tokens")) fs.mkdirSync("tokens");

  const formatsData = { HEX: { value: hex } };
  fs.writeFileSync("formats/formats.json", JSON.stringify(formatsData, null, 2));
  console.log("‚úÖ Saved: outputs/formats/formats.json");

  if (generateRGB) {
    const formatsRGBData = { stops: Object.fromEntries(Object.entries(stops).map(([k, v]) => [k, { value: tinycolor(v).toRgbString() }])) };
    fs.writeFileSync("formats/formats_rgb.json", JSON.stringify(formatsRGBData, null, 2));
    console.log("‚úÖ Saved: outputs/formats/formats_rgb.json");
  }

  if (generateRGBA) {
    const formatsRGBAData = { stops: Object.fromEntries(Object.entries(stops).map(([k, v]) => [k, { value: tinycolor(v).toRgbString() }])) };
    fs.writeFileSync("formats/formats_rgba.json", JSON.stringify(formatsRGBAData, null, 2));
    console.log("‚úÖ Saved: outputs/formats/formats_rgba.json");
  }

  if (generateHSL) {
    const formatsHSLData = { stops: Object.fromEntries(Object.entries(stops).map(([k, v]) => [k, { value: tinycolor(v).toHslString() }])) };
    fs.writeFileSync("formats/formats_hsl.json", JSON.stringify(formatsHSLData, null, 2));
    console.log("‚úÖ Saved: outputs/formats/formats_hsl.json");
  }

  const tokensData = { color: {} };

  if (variant) {
    tokensData.color[concept] = { [variant]: { value: hex, type: "color", stops: {} } };
  } else {
    tokensData.color[concept] = { value: hex, type: "color", stops: {} };
  }

  Object.keys(stops).forEach((shade) => {
    const target = variant ? tokensData.color[concept][variant].stops : tokensData.color[concept].stops;
    target[shade] = { value: tinycolor(stops[shade]).toHexString(), type: "color" };
  });

  if (generateRGB) {
    const tokensRGBData = JSON.parse(JSON.stringify(tokensData));
    fs.writeFileSync("tokens/tokens_rgb.json", JSON.stringify(tokensRGBData, null, 2));
    console.log("‚úÖ Saved: outputs/tokens/tokens_rgb.json");
  }

  if (generateRGBA) {
    const tokensRGBAData = JSON.parse(JSON.stringify(tokensData));
    fs.writeFileSync("tokens/tokens_rgba.json", JSON.stringify(tokensRGBAData, null, 2));
    console.log("‚úÖ Saved: outputs/tokens/tokens_rgba.json");
  }

  if (generateHSL) {
    const tokensHSLData = JSON.parse(JSON.stringify(tokensData));
    fs.writeFileSync("tokens/tokens_hsl.json", JSON.stringify(tokensHSLData, null, 2));
    console.log("‚úÖ Saved: outputs/tokens/tokens_hsl.json");
  }

  console.log("\n=======================================");
console.log(" üé® PROCESS COMPLETED SUCCESSFULLY!");
console.log("=======================================\n");

console.log("‚úÖ All files have been generated inside the 'formats/' and 'tokens/' folders.");
console.log("üìÅ You can now use them as needed.\n");

console.log("Thank you for using the color converter! üöÄüé®\n");
console.log("=======================================\n");

rl.close();


  rl.close();
};

main();
